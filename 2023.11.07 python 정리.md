<p><a target="_blank" href="https://app.eraser.io/workspace/URIk9Ihd7k3yZ7ZKfr9j" id="edit-in-eraser-github-link"><img alt="Edit in Eraser" src="https://firebasestorage.googleapis.com/v0/b/second-petal-295822.appspot.com/o/images%2Fgithub%2FOpen%20in%20Eraser.svg?alt=media&amp;token=968381c8-a7e7-472a-8ed6-4a6626da5501"></a></p>

                               

# Chapter 1
## 자료형
- `int` 
    - 정수형
    - 양의 정수와 음의 정수를 모두 포함
    - 파이썬은 숫자가 커지면 스스로 메모리를 더 사용함
- `float`  
    - **정수를 제외한** 실수를 부동소수점 수 또는 떠돌이 소수점 수
- `NoneType` 
    - 아무것도 없음을 표시하기 위해 만들어놓은 값
- `boolean(bool)` 
    - 참과 거짓을 나타내기 위한 값
- `string(str)` 
    - 문자열
    - 쌍따옴표 혹은 따옴표로 감싸야함
    - 쌍따옴표를 출력하고 싶다면 따옴표로 감싸야함
    - 따옴표를 출력하고 싶다면 쌍따옴표로 감싸야함
    - 둘다 출력하고 싶다면 '/'를 사용
    - 여러줄을 사용하고 싶다면 """사용
### index
- 순서가 0부터 시작함
- 뒤에서 순서를 뽑고 싶다면 음수를 사용
- `:` 를 써서 `[n:m]` 처럼 `n` 번째부터 `m` 번 직전까지를 한 번에 뽑아올 수도 있음
    - `n:m:l`을 사용해서 출력 구간을 정할 수 있음
    - 음수를 사용해 반대 순서부터 출력도 가능
### tuple
- 괄호`()`  안에 원하는 값들을 쉼표(`,` )로 구분
- 어떤 값이든 넣어도 가능
-  `[색인]`  문법을 써서 특정 위치의 값을 읽을 수 있음
- 값 변경 불가
- 튜플 안에 튜플을 넣을 수 있음
    - `[n]`  문법을 연이어 써서 튜플 안의 값 추출
- 덧셈 연산자를 통해 합치기 가능
- `in`  연산자를 써서  튜플 안에 특정한 값이 검사


### list
- 튜플과 거의 동일하나 []사용
- 값 변경 가능
- `.append()` 라는 특별한 함수를 뒤에 붙여서 값을 하나씩 추가
- `.remove()` 를 통해 특정 값 제외
-  `.pop()` 을 통해 특정 순서의 값을 제외


### dictionary
- 값을 여러 개 포함하는 컨테이너 자료형
- 직접 인덱스를 원하는 대로 지정
- 새로운 값을 추가하고 싶다면 그냥 새로운 키 추가
- `.pop()` 을 통해 특정 값 제외
-  `for`  루프문을 사용하면 기본적으로 키값만 출력
- `.items()` 를 사용하면 키와 값 둘다 출력
- 




## 함수(**function**)


- `def()` 로 사용
- 인자(argument): 함수를 호출할 때 전달하는 입력값
- 매개변수(parameter): 함수가 실행될 때 입력값이 들어올 변수
- 반환값(return value): 함수가 종료될 때 호출 지점으로 전달할 출력값
- 함수를 정의(define) 할 때 사용하는 일종의 예약어
- 함수가 끝날 때까지 띄어쓰기 4칸으로 들여쓰기를 해주어야 함
- 함수 내부에서 선언한 변수명은 외부에서 적용되지 않음
    - 이렇게 정의된 변수가 어디까지 유효한지 정의된 범위를 변수의 스코프(**scope**)라고함
    - 전역 스코프(**global scope**)와 지역 스코프(**local scope**)가 있음
- ()안에 입력값을 넣어서 사용가능
- 함수가 받을 매개변수의 기본값을 지정해 주면, 입력값이 없을 경우 해당 기본값을 사용하게 됨(ex. `**def say_hi_default(name='somebody'):**)`** **
- 입력값을 여러개 지정가능
- 입력값이 여러 개일 때도 각 입력값마다 기본값을 지정해 줄 수 있음
    - 기본값이 있는 인자들이 기본값이 없는 필수 인자들의 뒤에 와야 함
    - (ex.** def say_hi_couple_default(name1, name2='nobody'):**)
- 함수 결과와 변수를 더하고 싶다면  `return`으로 이 값을 출력값(output)으로서 반환(return)하라고 명시적으로 표시해 줘야 됨
- `pass`  문은 기타 제어 흐름 도구
## 
## 제어문(if)
- `if:` 로 사용
- 어떤 명제가 참인지 거짓인지에 따라 코드의 실행 여부를 결정
- 명제를 비교 연산자로 참 거짓 여부 판별
- 들여쓰기 된 코드 블록의 내용은 if 키워드 다음의 명제가 참일 때에만 실행
- `else:` 를 추가하여 거짓인 상황도 실행 여부를 결정
- `elif:` 를 추가하여 새로운 상황도 실행 여부를 결정
- and는 양쪽 명제 전부 참일 경우 작동 
- or은 양쪽 명제 중 한 쪽이라도 참일 경우 작동
- `if __name__ == '__main__':`  
    - 코드 시작점을 지정


## 제어문(while)
- `while:` 로 사용
- 조건이 참인 동안 반복
- 조건을 잘못 주게되면 무한 루프에 빠짐
## 제어문(for)
- `for i in j:` 로 사용
- 하나씩 순서대로 넘길(iterate) 수 있는 값들을 **반복 가능한(iterable, 이터러블) 객체**라고 함
- for문 안에 enumerate()라는 기능을 이용하여 리스트, 문자열, 튜플 등이 있는 경우 특정 순서와 리스트의 값을 함께 반환가능
- `for` 문의 개수에 따라서 몇 중의 `for` 문이고 생성 가능
- 리스트 컴프리헨션(list Comprehension)
    -  리스트 등 순회형 컨테이너 객체로부터 이를 가공한 새로운 리스트를 생성하는 아주 간결하고 편리한 방법
    - 리스트뿐 아니라 셋(Set), 딕셔너리(Dict)에 대해서도 적용 가능
- 제너레이터(Generator)
    -  `yield` 를 사용
    - 코드 실행의 순서를 밖으로 양보
## 재귀함수 
- 함수 내에서 그 함수 스스로를 사용하는 함수 종류
- 대표적인 예로 파보니치 수열이 있음
    - 앞의 두 숫자를 더한 수가 다음 수가 되는 무한수열
    - 피보나치 수열의 n번째 수는 n-1번째 수와 n-2번째 피보나치 수의 합
    - 피보나치 수열의 첫 번째 수와 두 번째 수는 1
    - 최초의 `n` 이 커질수록 속도는 기하급수적으로 느려짐


****

## 오류
- **구문 오류 (Syntax Error):** 코드를 파이썬 구문 규칙에 맞지 않게 작성했을 때 발생
- **런타임 오류 (Runtime Error):** 코드가 실행 중에 발생하는 오류로, 실행 중에 예외(exception)가 발생할 때 발생
- **논리 오류 (Logical Error):** 구문적으로나 런타임에서는 오류가 없지만, 프로그램이 예상대로 작동하지 않는 경우
- 형식 오류(**TypeError**): 데이터 형식(data type)이 잘못 사용되거나 혼합되는 경우 발생하는 예외(exception) 중 하나
- 참조 오류(**NameError**): 정의되지 않은 변수나 이름을 참조하려고 할 때 발생하는 예외(exception) 중 하나
- TypeError: unsupported operand type(s) for -: 'str' and 'str'
    - str은 연산 지원을 하지 않음
- NameError: name 'something' is not defined
    - 'something'이라는 변수명이 정의 되지않음
- IndentationError: unindent does not match any outer indentation level
    - 탭과 스페이스를 혼용해서 사용
- IndentationError: expected an indented block
    - 들여쓰기를 제대로 하지 않음
- missing 1 required positional argument
    - 함수 ()안에 변수를 입력하지 않음
- takes 0 positional arguments but 1 was given
    - 함수 ()안에는 미리 정의된 변수를 넣어야함
- got an unexpected keyword argument
    - 지정된 인자가 아닌 다른 인자를 입력함
- 함수의 인수는 함수가 호출되기 전에 먼저 평가됨
    - `**print_two('A', print_and_return('B', 'C', 'D'))**`가 
실행될 때 'A'가 먼저 출력되는 것이 아니라, 
함수 `**print_and_return('B', 'C', 'D')**` 가 먼저 호출되고 
그 결과가 `**print_two**`  함수의 인수로 전달됨


# Chapter 2
### 파이썬의 성능 
1. 높은 생산성
    1. `pip` 를 통해 얼마든지 쉽게 설치할 수 있는 써드파티 라이브러리를 통해 개발 기간을 크게 단축
2. 코드의 간결함
3. 빠른 개발 속도
4. 스크립트 언어(인터프리터 언어)


컴파일 언어와 스크립트 언어(인터프리터 언어)의 각 특징

**컴파일 언어**

- 실행 전 소스 코드를 컴파일하여 기계어로 변환 후 해당 파일을 실행
- 이미 기계어로 변환된 것을 실행하므로 비교적 빠름
- 컴파일 시점에 소스 코드의 오류를 잡기 쉬움
- 같은 소스 코드도 다른 환경(PC, mobile 등)에서 실행하려면 다시 컴파일(기계어로 변환) 해야함
**스크립트 언어(인터프리터 언어)**

- 코드를 작성함과 동시에 인터프리터가 기계어로 번역하고 실행함
- 코드 번역 과정이 있어 비교적 느림
- 주 사용 목적이 뚜렷하게 개발되어 사용하기 쉬운 편
- 명령줄로 코드를 즉시 실행할 수 있음


### Try - Except 예외 처리
- 예외(exception)란 코드를 실행하는 중에 발생한 에러
- 예외 처리는 코드를 수행하다가 예외(에러)가 발생했을 때 그 예외(에러)를 무시하게 하거나 예외(에러) 대신 적절한 처리를 해주게 하는 등의 작업을 의미
- 코드상에서 어떠한 이유로 인해 에러가 발생하면 `Except`  안에 있는 코드가 바로 실행
- `try:`   

`except:`  를 사용


### Multiprocessing
- 성능 개선을 위해 사용
- pool = multiprocessing.Pool(processes = 2)
    - processes= 옆에 원하는 프로세스의 숫자 입력
    - 코어의 개수는 터미널에 `**grep -c processor /proc/cpuinfo**`  명령어로 확인
- `**pool.map(count, num_list)**` 
    -  병렬화를 시키는 함수
    - count 함수에 num_list의 원소들을 하나씩 대입




- `**pool.close()**` 
    - 일반적으로 병렬화 부분이 끝날때 사용
    - 더 이상 pool을 통해서 새로운 작업을 추가하지 않을 때 사용
- `**pool.join()**`  
    - 프로세스가 종료될 때까지 대기하도록 지시하는 구문
    - 병렬처리 작업이 끝날 때까지 대기


### 람다 표현식(lambda expression)
```
print( (lambda x,y: x + y)(10, 20) )
```
- 먼저 `**x**` , `**y**`  는 입력값을 의미합니다. 즉, `**x**` 값과 `**y**` 값이 입력으로 들어온다는 의미입니다.
- 두 번째, `**x + y**` 는 `**return**`  부분과 같습니다. `**add**`  함수에도 `**return x + y**` 가 있었던 것과 같이 lambda 에도 '`**:**` ' 이후에 반환값으로 나오게 됩니다.
- 마지막은 (10, 20) 입니다. 각각 앞에 있던 `**x**` , `**y**`  입력값입니다. 만약 입력이 `**x**` , `**y**` , `**z**`  이라면 (10, 20, 30) 이렇게 세 개의 값을 넣게 됩니다. 보통 함수 안의 함수를 간단히 만들 때, `**def**` 를 이용해 만들지 않고 람다를 이용해서 함수를 만들게 됩니다.
람다 표현식을 사용하는 가장 중요한 이유는 함수의 인수 부분을 간단히 하기 위함입니다. 이런 방식으로 사용하는 대표적인 예가 `map()`입니다.

`map()` 함수는 입력받은 자료형의 각 요소가 함수에 의해 수행된 결과를 묶어서 map iterator 객체로 출력하는 역할을 합니다.



### 클래스(Class)
클래스는 비슷한 역할을 하는 함수들의 집합이라고 볼 수 있습니다. 



### 모듈(Module)
모듈은 함수, 변수, 클래스를 모아 놓은 파일을 말합니다. 즉, 코드의 저장소라고 볼 수 있습니다.

```
code = '# mycalculator.py\ntest = "you can use this module."\n\ndef add(a, b):\n    return a + b\n \ndef mul(a, b):\n    return a * b\n\ndef sub(a, b):\n    return a - b\n\ndef div(a, b):\n    return a / b\n\n\nclass all_calc():\n\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def add(self):\n        return self.a + self.b\n \n    def mul(self):\n        return self.a * self.b\n\n    def sub(self):\n        return self.a - self.b\n\n    def div(self):\n        return self.a / self.b'

f = open("mycalculator.py", "w")
f.write(code)
f.close()
```
먼저 `mycalculator`를 `import` 합니다.

```
# import 모듈이름
import mycalculator
```
사용

```
**# 모듈이름.함수이름()
print(mycalculator.add(4, 2))**
```
### 패키지
키지(라이브러리)는 전 세계의 파이썬 사용자들이 만든 유용한 프로그램을 모아 놓은 보물 주머니 같은 것입니다.

거의 모든 패키지는 `pip` 명령어를 통해서 설치할 수 있습니다.



### 절차 지향 프로그래밍과 객체 지향 프로그래밍
---

**절차 지향 프로그래밍**
일이 진행되는 순서대로 프로그래밍하는 방법입니다.

- 장점 : 코드가 순차적으로 작성되어 있어 순서대로 읽기만 하면 이해가 가능합니다.
- 단점 : 순차적으로 작성되어 있기 때문에 위에서 하나가 잘못되면 아래도 연쇄적으로 문제가 생겨서 유지 보수가 어렵습니다. 일반적으로 코드 길이가 길어서 코드를 분석하기 어렵습니다.
**객체 지향 프로그래밍**
객체지향 프로그래밍은 개발자가 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있게 합니다. 객체를 먼저 작성하고 함수를 작성합니다. 이렇게 작성된 객체는 객체 간의 상호작용이 있습니다.

- 장점 : 코드를 재사용하기 쉽습니다. 코드 분석이 쉬우며 아키텍처를 바꾸기 쉽습니다.
- 단점 : 객체 간의 상호작용이 있기 때문에 설계에서 많은 시간이 소요되며 설계를 잘못하면 전체적으로 바꿔야 할 수도 있습니다.
- 파이썬은 객체지향 프로그래밍(OOP, Object Oriented Programming) 패러다임을 기본적으로 지원하고 있습니다.


### 함수형 프로그래밍
---

**함수형 프로그래밍**은 데이터 사이언티스트에게 적합한 프로그래밍 패러다임입니다. 함수형 프로그래밍은 효율성, 버그 없는 코드, 병렬 프로그래밍과 같은 장점을 제공합니다.

함수형 프로그래밍은 함수로 문제를 분해합니다. 이 함수들은 입력을 받아서 출력을 만들어 내기만 하며, 주어진 입력이 함수를 통과하고 값이 생성되면 이 출력값은 함수 외부의 다른 변수나 함수에 의해 변하지 않습니다.

### **함수형 프로그래밍의 특징**
**1. 순수성**

**함수형 프로그램에서 각 함수는 입력으로부터 동작을 시작해 출력을 만들어 냅니다. 함수형 방식은 내부 상태를 수정하거나 함수의 반환값에서 보이지 않는 다른 변경사항들을 만드는 부작용이 있는 함수를 사용하지 않습니다. 부작용이 전혀 없는 함수를 순수 함수 라고 합니다. 부작용을 피한다는 것은 프로그램이 실행될 때 해당 프로그램이 수정될 수 있는 상황을 엄격히 제한한다는 의미입니다. 그리고 모든 함수의 출력은 입력에만 의존해야 합니다.**

**2. 모듈성**

**함수형 프로그래밍은 문제를 작은 조각으로 분해하도록 강제합니다. 복잡한 변환을 한 함수 안에서 수행하는 거대한 함수보다, 한 가지 작업을 수행하는 작은 함수들로 쪼개어 만드는 것이 코딩하기에 더 쉽습니다. 작은 함수는 가독성도 좋고 오류를 확인하기도 더 쉽습니다. 결과적으로 프로그램은 더욱 모듈화가 됩니다.**

**3. 디버깅과 테스트 용이성**

**함수형 프로그래밍으로 개발된 프로그램은 각각의 함수가 작고 명확하게 명시되기 때문에 디버깅을 쉽게 할 수 있습니다. 프로그램이 동작하지 않는다면, 각 함수는 데이터가 올바른지 확인할 수 있는 포인트들이 됩니다. 각 함수의 입력과 출력을 확인하면서 예상되는 것과 다른 출력이 나오면 해당 부분이 문제이기 때문에 디버깅이 쉽습니다.**

**각 함수는 잠재적으로 단위 테스트의 대상이기 때문에 테스트가 더 쉽습니다. 올바른 입력을 함수에 입력하고 결과가 예상과 일치하는지 확인만 하면 되기 때문이죠.**

### 네이밍 컨벤션(Naming convention)
---

실무에선 다른 사람들과 같이 코드를 짜야 하는 경우가 많습니다. 사람들마다 변수명을 적는 방식이 다르면 코드가 깔끔해 보이지 않기 때문에 가독성이 안 좋습니다. 가독성이 좋은 코드를 짜는 방법은 통일성을 갖는 것입니다. 통일성을 갖기 위해선 사람들이 공유하는 코딩 스타일 가이드가 필요합니다. 그래서 파이썬에서는 pep8 이라는 코딩 스타일 가이드를 가지고 있습니다. pep8 코딩 스타일 가이드는 위에서 소개했기 때문에 이번엔 이름을 작성할 때 사용하는 네이밍 컨벤션에 대해서 알아보겠습니다.

대표적인 네이밍 컨벤션은 snake_case, PascalCase, camelCase 입니다. 각 네이밍 컨벤션의 기준에 맞춰 코드를 작성하시면 가독성이 높은 코드가 됩니다.

**snake_case**

- 모든 공백을 "_"로 바꾸고 모든 단어는 소문자입니다.
- 파이썬에서는 함수, 변수 등을 명명할 때 사용합니다.
- ex) this_snake_case
**PascalCase**

- 모든 단어가 대문자로 시작합니다.
- UpperCamelCase, CapWords라고 불리기도 합니다.
- 파이썬에서는 클래스를 명명할 때 사용합니다.
- ex) ThisPascalCase
**camelCase**

- 처음은 소문자로 시작하고 이후의 모든 단어의 첫 글자는 대문자로 합니다.
- lowerCamelCase라고 불리기도 합니다.
- 파이썬에서는 거의 사용하지 않습니다 (Java 등에서 사용)
- ex) thisCamelCase
### 객체
"파이썬(Python)에서 모든 것은 객체(object)다. 그래서 거의 모든 것이 **속성(attributes)** 과 **메서드(methods)** 를 갖는다." 고 하는데요. 변수의 묶음이 되는 속성과 연관된 함수를 엮어 놓은 메서드로 이루어졌다는 말입니다.

참조하는 데이터의 id만을 복사하는 것을 **얕은 복사**라고 합니다

이런 복사를 파이썬을 비롯한 프로그래밍에서는 **깊은 복사**라고 합니다.

객체는 상태(state)를 나타내는 속성(attribute)과 동작(behavior)을 나타내는 메서드(method)가 있습니다.
-객체의 속성은 변수로 구현되고, 객체의 메서드는 함수로 구현됩니다.

객체를 활용한 프로그래밍을 **객체 지향 프로그래밍(OOP: Object Oriented Programming)** 이라고 합니다.



### 클래스 사용 - 객체 인스턴스화
---

클래스를 이용하려면 클래스로 객체를 만들어 주어야 하는데요. 이를 **인스턴스화**라고 합니다.

인스턴스화는 어떻게 할까요? 선언한 클래스 이름에 괄호를 적어 줍니다. 그리고 생성된 인스턴스를 적당한 변수에 할당해서 사용합니다.



### 클래스의 속성과 메서드
---

앞서 클래스는 개발자가 객체를 설계하기 위한 것이라고 했습니다. 그리고 맨 처음에 객체에는 속성과 메서드가 있다고 배웠습니다.
그럼 클래스에서 속성과 메서드를 구현할 수 있어야겠죠?

- 클래스의 속성은 상태(state)를 표현합니다. 속성은 변수로 나타냅니다.
- 클래스의 메서드는 동작(behavior)을 표현합니다. 메서드는 `**def**`  키워드로 나타냅니다.
---

- 상속 
    - 자식 클래스
    - 부모 클래스
    - 사용방법 
        - 메서드 추가 
            - 메서드 추가
        - 메서드 재정의 
            - override - 메서드를 변경하는 것
        - 부모 메서드 호출 
            - super()
                - 부모 클래스가 변경 되었을 경우 오버라이드는 하나하나 찾아가서 다시 변경해주어야 겠지만 super을 사용하면 변경 사항이 그대로 자식 클래스에 반영되기 때문



<!--- Eraser file: https://app.eraser.io/workspace/URIk9Ihd7k3yZ7ZKfr9j --->